---
title: Testing
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## Why we need to test

Testing is essential to test the quantity of an application to meet both the functional requirements or non-functional requirements. Of course, we are able to test it manually but the problems are:
- It’s so time-consuming and easy to overlook bugs because of the human factor. 
- When we deploy new features or bug-fixing release, we may introduce more bugs and things need to be retest again

That’s why we start to automate and write them. It gives us confidence that we made no mistake in the path of a use case and the automation speeds up the whole process. Both developers and QA engineers write tests. Anyway, we still need to do manual tests because not everything can be covered with automation, so we have also QA manual testers.


### Types of Software Testing

Software Testing is a crucial phase of the software development cycle. There are many different types of software testing. Each of these testing types has its own purpose. The type of software testing that you choose depends on your testing objective, the complexity, and functionality of your software, and your testing team. The image below lists out some of the most common types of software testing used today.

![](/img/software-development/devops/testing/TestingTypes-768x644.png)

Source: [Smoke Testing and Sanity Testing: How are they different?](https://www.edureka.co/blog/smoke-testing-and-sanity-testing)

### Functional Testing

There must be something that defines what is acceptable behavior and what is not.

This is specified in a functional or requirement specification. It is a document that describes what a user is permitted to do so, that he can determine the conformance of the application or system to it. Additionally, sometimes this could also entail the actual business side scenarios to be validated.

Therefore, functionality testing can be carried out via two popular techniques:

- Testing based on Requirements: Contains all the functional specifications which form a basis for all the tests to be conducted.
- Testing based on Business scenarios: Contains the information about how the system will be perceived from a business process perspective.

Testing and Quality Assurance are a huge part of the SDLC process. As a tester, we need to be aware of all the types of testing even if we're not directly involved with them daily.

### Non-Functional Testing

Non-Functional Testing is a type of testing used to evaluate a software application's performance, [usability](https://www.browserstack.com/guide/website-usability-testing "Website Usability Testing: A Beginner's Guide"), dependability, and other non-functional characteristics. It is intended to test a system's readiness according to non-functional criteria that functional testing never considers.

Non Functional testing is essential for confirming the software's reliability and functionality. The Software Requirements Specification (SRS) serves as the basis for this software testing method, which enables quality assurance teams to check if the system complies with user requirements. Increasing the product's usability, effectiveness, maintainability, and portability is the goal of non-functional testing. It aids in lowering the manufacturing risk associated with the product's non-functional components.

There are lots of non-funational testing, to name a few well-known names - Performance testing, security testing, Reliablity testing, volumne testing, recoverying testing and visual testing. You may check the full list in [browserstack](https://www.browserstack.com/guide/what-is-non-functional-testing)



### End to End Testing

End to end testing (E2E testing) is a software testing method that involves testing an application’s workflow from beginning to end. This method aims to replicate real user scenarios to validate the system for integration and data integrity.

Essentially, the test goes through every operation the application can perform to test how the application communicates with hardware, network connectivity, external dependencies, databases, and other applications. Usually, E2E testing is executed **after functional and system testing** is complete.

Naturally, detecting bugs in a complex workflow entails challenges. The two major ones are explained below:

- **Creating workflows**: To examine an app's workflow, test cases in an E2E test suite must be run in a particular sequence. This sequence must match the path of the end-user as they navigate through the app. Creating test suites to match this workflow can be taxing, especially since they usually involve creating and running thousands of tests.
- **Accessing Test Environment**: It is easy to test apps in dev environments. However, every application has to be tested in client or production environments. Chances are that prod environments are not always available for testing. Testers must install local agents and log into virtual machines even when they are. Testers must also prepare for and prevent issues like system updates that might interrupt test execution.

## Functional Testing Types

Functional testing has many categories and these can be used based on the scenario.

The most prominent types are briefly discussed below:

[Unit Testing](https://www.softwaretestinghelp.com/unit-testing/): Unit testing is usually performed by a developer who writes different code units that could be related or unrelated to achieve a particular functionality. His, this usually entails writing unit tests which would call the methods in each unit and validate those when the required parameters are passed, and its return value is as expected.

Code coverage is an important part of unit testing where the test cases need to exist to cover the below three:

- Line coverage
- Code path coverage
- Method coverage

[Smoke Testing](https://www.softwaretestinghelp.com/smoke-testing-and-sanity-testing-difference/): Smoke tests are basic tests that check the basic functionality of an application. They are meant to be quick to execute, and their goal is to give you the assurance that the major features of your system are working as expected. It is also called as **build verification testing**. 
- To execute smoke tests, **you don’t need to write new test cases**, instead, you can just pick the necessary test cases that are already defined by programmers.
- **Objective**: Smoke Testing rejects a badly broken application so that the QA team does not waste time installing and testing the software application. Instead of performing exhaustive testing, we make sure that critical functionalities are working fine.
- **When**: 
    - Testing that is done **after each build is made** to ensure build stability to decide whether or not you can run more expensive tests, 
    - or **right after a deployment** to make sure that they application is running properly in the newly deployed environment.

[Sanity Testing](https://www.softwaretestinghelp.com/smoke-testing-and-sanity-testing-difference/): Testing that is done to ensure that all the major and vital functionalities of the application/system are working correctly. Similar to smoke testing, **you don’t need to write new test cases** unless a new feature is introduced.
- **Objective**: Sanity test is not to verify the core functionalities, instead, it is to verify the correctness and rationality(Sanity) of the software. For instance, if your scientific calculator gives the result of 2 + 2 =5! Then, there is no point testing the advanced functionalities like sin 30 + cos 50
- **When**: It is usually done **after a smoke test** when the build is stable, to ascertain if bugs have been fixed and if minor changes to the code are well tolerated.

[Regression Tests](https://www.softwaretestinghelp.com/regression-testing-tools-and-methods/): Testing performed to ensure that adding new code, enhancements, fixing of bugs is not breaking the existing functionality or causing any instability and still works according to the specifications.It is executed based on the project and availability of resources, manpower and time.

Regression tests need not be as extensive as the actual functional tests but should ensure just the amount of coverage to certify that the functionality is stable.

[Integration Tests](https://www.softwaretestinghelp.com/what-is-integration-testing/): When the system relies on multiple functional modules that might individually work perfectly, but have to work coherently when clubbed together to achieve an end to end scenario, validation of such scenarios is called Integration testing.

[Beta/Usability Testing](https://www.softwaretestinghelp.com/usability-testing-guide/): Product is exposed to the actual customer in a production like an environment and they test the product. The user's comfort is derived from this and the feedback is taken. This is similar to that of User Acceptance testing.

#### Testing flow


```mermaid
flowchart TD
    A[Code] --> B[Unit Test] 
    B[Unit Test] --> C[Integration Test] 
    C[Integration Test] --> D[Smoke Test]
    D[Smoke Test] --> E[Sanity Test]
    E[Sanity Test] --> F[System test / Regression test]
    style F fill:#bbf,stroke:#f66,stroke-width:2px,color:#fff,stroke-dasharray: 5 5
```

### Testing diagrams

<Tabs className="tests">
<TabItem value="regression" label="Regression">

![](https://browserstack.wpenginepowered.com/wp-content/uploads/2019/09/Regression-testing-tutorual.png "Re")

Source: [Stackify](https://stackify.com/wp-content/uploads/2017/04/regression_graph.png)

</TabItem>
</Tabs>

### Unit, Integration And Functional Testing

#### Cost and time

![result-for-unit-testing-vs-functional-testin](/img/software-development/devops/testing/result-for-unit-testing-vs-functional-testin.png)

Source: [The Differences Between Unit Testing, Integration Testing And Functional Testing](https://www.softwaretestinghelp.com/the-difference-between-unit-integration-and-functional-testing/)


#### Example

Almost every web application requires its users/customers to log in. For that, every application has to have a "Login" page which has these elements:

- Account/Username
- Password
- Login/Sign in Button

For **Unit Testing**, the following may be the test cases:

- Field length - username and password fields.
- Input field values should be valid.
- The login button is enabled only after valid values (Format and lengthwise) are entered in both the fields.

For **Integration Testing**, the following may be the test cases:

- The user sees the welcome message after entering valid values and pushing the login button.
- The user should be navigated to the welcome page or home page after valid entry and clicking the Login button.

Now, after unit and integration testing are done, let us see the additional test cases that are considered for **functional testing**:

1. The expected behavior is checked, i.e. is the user able to log in by clicking the login button after entering a valid username and password values.
2. Is there a welcome message that is to appear after a successful login?
3. Is there an error message that should appear on an invalid login?
4. Are there any stored site cookies for login fields?
5. Can an inactivated user log in?
6. Is there any 'forgot password' link for the users who have forgotten their passwords?


#### Marjar differences

|                        | Unit testing                                                 | Integration testing                                                               | Functional testing                                                                                                                        |
| ---------------------- | ------------------------------------------------------------ | --------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------- |
| Definition and purpose | Testing smallest units or modules individually.              | Testing integration of two or more units/modules combined for performing tasks.   | Testing the behavior of the application as per the requirement.                                                                           |
| Complexity             | Not at all complex as it includes the smallest codes.        | Slightly more complex than unit tests.                                            | More complex compared to unit and integration tests.                                                                                      |
| Testing techniques     | White box testing technique.                                 | White box and black box testing technique. Grey box testing                       | Black box testing technique.                                                                                                              |
| Major attention        | Individual modules or units.                                 | Integration of modules or units.                                                  | Entire application functionality.                                                                                                         |
| Error/Issues covered   | Unit tests find issues that can occur frequently in modules. | Integration tests find issues that can occur while integrating different modules. | Functional tests find issues that do not allow an application to perform its functionality. This includes some scenario-based issues too. |
| Issue escape           | No chance of issue escape.                                   | Less chance of issue escape.                                                      | More chances of issue escape as the list of tests to run is always infinite.                                                              |


### Smoke Testing vs Sanity Testing

The are both related a build. Smoke Testing has a goal to verify “stability” whereas Sanity Testing has a goal to verify “rationality”.

![Smoke Testing vs Sanity Testing](/img/software-development/devops/testing/Sanity_Smoke_Testing.webp)

Source: [guru99 - Sanity Testing Vs. Smoke Testing – Difference Between Them](https://www.guru99.com/smoke-sanity-testing.html)


#### Smoke Testing example




#### Sanity Testing example

Consider you developing an online Food ordering app, and you want to offer a 10% discount on New Year (1st January) for your members having an elite membership.

Sanity testing will verify the following:

-  Elite members get the discount on the 1st January.
-  Members, who add the elite membership to their food orders on the 1st, also get the discount.
-  Non-elite members do not get the discount on the 1st January .
-  No member receives that rebate before and after the 1st January.
-  Other discount coupons can not be clubbed together with this 10% discount.
-  Elite members, who opt for other deals, do not get the New Year deduction.

Sanity testing does not verify other areas of the app, like delivery tracking or restaurant reviews. That is done by Smoke testing and Regression testing, which happen before and after Sanity testing. 

If Sanity testing fails, the app is sent back to the developer for troubleshooting. However, if it succeeds, the app is sent for thorough System testing.


#### Comparison table

| Features          | Smoke Testing                                                                           | Sanity Testing                                                                        |
|-------------------|-----------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------|
| System Builds     | Tests are executed on initial builds of software product                                | Tests are done over builds that have passed smoke tests & rounds of regression tests  |
| Motive of Testing | To measure the stability of the newly created build to face off more rigorous testing   | To evaluate rationality & originality of the functionalities of software builds       |
| Subset of?        | Is a subset of **acceptance testing **                                                      | Is a subset of **regression testing**                                                     |
| Documentation     | Involves documentation and scripting work                                               | Doesn’t emphasize any sort of documentation                                           |
| Test Coverage     | Shallow & wide approach to include all the major functionalities without going too deep | Narrow & deep approach involving detailed testing of functionalities and features     |
| Performed By?     | Executed by developers or testers                                                       | Executed by testers                                                                   |


### Tools 

#### Unit test for javascript

![](/img/software-development/devops/testing/frameworks-time.png)
![](/img/software-development/devops/testing/compare-testing-frameworks.png)

Source: [Javascript unit test frameworks](https://raygun.com/blog/javascript-unit-testing-frameworks/)

## Design test cases

### How to perform Automated Functional Testing?

The steps involved in automated functional testing are given below:

- **Determine Functionality: **The first of functional testing is to determine the functionality of the product that needs to be tested and it includes testing the main functionalities, error conditions, and messages.
- **Create Input Data: **Next step is to create the input data for the functionality to be tested as per the requirements specification.
- **Determine Output: **After creating the input data, the output is determined for the functionality under test. 
- **Execute test cases: **After determining the required output, the prepared test cases are executed.
- **Compare Outputs: **Finally, the output obtained after executing the test case and the expected output are compared to find whether the functionality is working as expected or not.

### Decide a test case

**TO-DO:** how to know what to test https://kentcdodds.com/blog/how-to-know-what-to-test



## Examples

### End-to-end test with jest-puppeteer

> Reference: [Jest - Using with puppeteer](https://jestjs.io/docs/puppeteer)

- Jest is **a test runner**. It doesn't care what type of tests you run, and you can use it for any type of tests.
- Jest is a JavaScript testing framework designed to ensure correctness of any JavaScript codebase. It allows you to write tests with an approachable, familiar and feature-rich API that gives you results quickly. 
- Puppeteer framework offers **Headless Browser Testing for Google Chrome**. It allows the tester to perform the actions on the Chrome browser using commands in JavaScript. It provides a high-level API for controlling headless Chrome through Chrome DevTools Protocol. This DevTools Protocol offers tools to instrument, debug, inspect, and profile the Chromium or Chrome browsers.  
- [Jest Puppeteer](https://github.com/smooth-code/jest-puppeteer) provides all required configuration to run your tests using Puppeteer.


:::infoWhat is Headless Browser Testing? 
Headless Browsers play a major role in CI/CD, as these web browsers provide automated control of the web page without any graphical user interface (GUI). This allows the tester to perform automation testing on the web application using a command-line interface without testing the whole site by performing actions through the GUI.

Headless Browser Testing speeds up the QA process, which is required in CI/CD, where quick feedback is required to ensure the high performance of the application. It generates faster results even with a high volume of test cases, with due consistency and accuracy, which helps save time and resources. 
:::

:::info4 Characteristics of Jest
- **Zero config:** "Jest aims to work out of the box, config free, on most JavaScript projects." This means you can simply install Jest as a dependency for your project, and with no or minimal adjustments, you can start writing your first test.
- **Isolated:** Isolation is a very important property when running tests. It ensures that different tests don't influence each other's results. For Jest, tests are executed in parallel, each running in their own process. This means they can't interfere with other tests, and Jest acts as the orchestrator that collects the results from all the test processes.
- **Snapshots:** Snapshots are a key feature for front-end testing because they allow you to verify the integrity of large objects. This means you don't have to write large tests full of assertions to check if every property is present on an object and has the right type. You can simply create a snapshot and Jest will do the magic. Later, we'll discuss in detail how snapshot testing works.
- **Rich API:** Jest is known for having a rich API offering a lot of specific assertion types for very specific needs. Besides that, its [great documentation](https://jestjs.io/docs/en/getting-started) should help you get started quickly.
:::

1.  First, install `jest-puppeteer`

- npm
- Yarn

```js
npm install --save-dev jest-puppeteer
```

2.  Specify preset in your [Jest configuration](https://jestjs.io/docs/configuration):

```js
{  "preset": "jest-puppeteer"}
```

3.  Write your test

```js
describe('Google', () => {
  beforeAll(async () => {
    await page.goto('https://google.com');
  });

  it('should be titled "Google"', async () => {
    await expect(page.title()).resolves.toMatch('Google');
  });

  it('should load without error', async () => {
      let text = await page.evaluate(() => document.body.textContent);
      expect(text).toContain('google');
  });

  it('should contain a Google Search and Lucky button', async () => {
      await expect(page).toMatchElement('input[name="btnK"][value="Google Search"]');
      await expect(page).toMatchElement(`input[name="btnI"][value="I'm Feeling Lucky"]`);
  });

  it('should have app with link and sign in button', async () => {
    const app_btn = await expect(page).toMatchElement('.gb_D.gb_sc');
    let text = await page.evaluate(element => element.href, app_btn);
    expect(text).toBe('https://www.google.com.sg/intl/en/about/products?tab=wh');

    const sign_btn = await expect(page).toMatchElement('#gb_70');
    text = await page.evaluate(element => element.innerHTML, sign_btn);
    expect(text).toBe('Sign in');
  });
});
```

4. Checking the result

![testing result](/img/software-development/devops/testing/testing-results.png)


There's no need to load any dependencies. Puppeteer's `page` and `browser` classes will automatically be exposed

See [documentation](https://github.com/smooth-code/jest-puppeteer).


### API Testing With Jest And SuperTest

> Full tutorial: [Building A Scalable API Testing Framework With Jest And SuperTest](https://www.velotio.com/engineering-blog/scalable-api-testing-framework-with-jest-and-supertest)

- [SuperTest](https://www.npmjs.com/package/supertest) is a node library, [superagent](https://www.npmjs.com/package/superagent) driven, to extensively test Restful web services. It hits the HTTP server to send requests (GET, POST, PATCH, PUT, DELETE ) and fetch response
- [testSequencer](https://jestjs.io/docs/configuration#testsequencer-string): to invoke testSequencer.js in the workspace to customize the order of running our test files
- [jest-stare](https://dkelosky.github.io/jest-stare/) for generating custom test reports

```js 
// testSequencer.js 
const Sequencer = require('@jest/test-sequencer').default;

class CustomSequencer extends Sequencer {
  sort(tests) {
    // Test structure information
    // https://github.com/facebook/jest/blob/6b8b1404a1d9254e7d5d90a8934087a9c9899dab/packages/jest-runner/src/types.ts#L17-L21
    const copyTests = Array.from(tests);
    return copyTests.sort((testA, testB) => (testA.path > testB.path ? 1 : -1));
  }
}

module.exports = CustomSequencer;
```

```json
// package.json
{
  "name": "supertestjest",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "jest": {
    "verbose": true,
    "testSequencer": "/home/abc/jest-supertest/testSequencer.js",
    "coverageDirectory": "/home/abc/jest-supertest/coverage/my_reports/",
    "coverageReporters": ["html","text"],
    "coverageThreshold": {
      "global": {
        "branches": 100,
        "functions": 100,
        "lines": 100,
        "statements": 100
      }
    }
  },
  "scripts": {
    "test": "NODE_TLS_REJECT_UNAUTHORIZED=0 jest --reporters default jest-stare --coverage --detectOpenHandles --runInBand --testTimeout=60000",
    "test:watch": "jest --verbose --watchAll"
  },
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "jest": "^25.5.4",
    "jest-serial-runner": "^1.1.0",
    "jest-stare": "^2.0.1",
    "supertest": "^4.0.2"
  }
}
```

```js
// commonTests.js - SuperTest wrapper to store authorization token
var supertest = require('supertest'); //require supertest
const request = supertest('https://reqres.in/'); //supertest hits the HTTP server (your app)

/*
This piece of code is for getting the authorization token after login to your app.
const token;
test("Login to the application", function(){
    return request.post(``).then((response)=>{
        token = response.body.token  //to save the login token for further requests
    })
}); 
*/

module.exports = 
{
    request
        //, token     -- export if token is generated
}
```


```js
/* postAndGet.test.js
- POST requests to api/users endpoint, calls supertest.post() 
- GET requests to api/users endpoint, calls supertest.get()
- uses file system to write globals and read those across all the tests
- validates response returned on hitting the HTTP endpoints
*/
const request = require('../commonTests');
const fs = require('fs');
let userID;

//Create a new user
describe("POST request", () => {
  
  try{
        let userDetails;
        beforeEach(function () {  
            console.log("Input user details!")
            userDetails = {
                "name": "morpheus",
                "job": "leader"
            }; //new user details to be created
        });

        afterEach(function () {
            console.log("User is created with ID : ", userID)
        });

        it("Create user data", async done => {

            return request.request.post(`api/users`) //post() of supertest
                //.set('Authorization', `Token $  {request.token}`) //Authorization token
                .send(userDetails) //Request header
                .expect(201) //response to be 201
                .then((res) => {
                    expect(res.body).toBeDefined(); //test if response body is defined
                    //expect(res.body.status).toBe("success")
                    userID = res.body.id;
                    let jsonContent = JSON.stringify({userId: res.body.id}); // create a json
                    fs.writeFile("data.json", jsonContent, 'utf8', function (err) //write user id into global json file to be used 
                    {
                        if (err) {
                            return console.log(err);
                        }
                        console.log("POST response body : ", res.body)
                        done();
                    });
                })
            }) 
    }catch(err){
        console.log("Exception : ", err)
    }
});

//GET all users      
describe("GET all user details", () => {
  
  try{
      beforeEach(function () {
        console.log("GET all users details ")
    });
          
      afterEach(function () {
        console.log("All users' details are retrieved")
    });

      test("GET user output", async done =>{
        await request.request.get(`api/users`) //get() of supertest
                                //.set('Authorization', `Token ${request.token}`) 
                                .expect(200).then((response) =>{
                                console.log("GET RESPONSE : ", response.body);
                                done();
                    })
      })
    }
  catch(err){
    console.log("Exception : ", err)
    }
});
```

```js
/* putAndDelete.test.js
- calls data.json into ‘data’ alias which was created by the file system in our previous test to write global variables into it
- PUT sto api/users/${data.userId} endpoint, calls supertest.put() 
- DELETE requests to api/users/${data.userId} endpoint, calls supertest.delete() 
- validates response returned by the endpoints
- removes data.json (similar to unsetting global variables) after all the tests are done
*/

const request = require('../commonTests');
const fs = require('fs'); //file system
const data = require('../data.json'); //data.json containing the global variables

//Update user data
describe("PUT user details", () => {

    try{
        let newDetails;
        beforeEach(function () {
            console.log("Input updated user's details");
            newDetails = {
                "name": "morpheus",
                "job": "zion resident"
            }; // details to be updated
  
        });
        afterEach(function () {
            console.log("user details are updated");
        });
  
        test("Update user now", async done =>{

            console.log("User to be updated : ", data.userId)

            const response = await request.request.put(`api/users/${data.userId}`).send(newDetails) //call put() of supertest
                                //.set('Authorization', `Token ${request.token}`) 
                                        .expect(200)
            expect(response.body.updatedAt).toBeDefined();
            console.log("UPDATED RESPONSE : ", response.body);
            done();
    })
  }
    catch(err){
        console.log("ERROR : ", err)
    }
});

//DELETE the user
describe("DELETE user details", () =>{
    try{
        beforeAll(function (){
            console.log("To delete user : ", data.userId)
        });

        test("Delete request", async done =>{
            const response = await request.request.delete(`api/users/${data.userId}`) //invoke delete() of supertest
                                        .expect(204) 
            console.log("DELETE RESPONSE : ", response.body);
            done(); 
        });

        afterAll(function (){
            console.log("user is deleted!!")
            fs.unlinkSync('data.json'); //remove data.json after all tests are run
        });
    }

    catch(err){
        console.log("EXCEPTION : ", err);
    }
});
```

Test results HTML report is also generated as index.html under *jest-stare/ *

![API test](/img/software-development/devops/testing/api-test.png)


### Automated Regression Testing with perfecto

[Test automation](https://www.perfecto.io/blog/what-is-test-automation) is always preferred by most organizations when it comes to testing. However, finding what should be automated and how to automate it can be challenging.

Creating stable and robust testing scripts can be quite complicated and requires experience to get it right. Besides, scaling the entire automation process is also another hurdle for most organizations that are inexperienced in DevOps.

There are quite a number of tools that help streamline the entire testing process for you. For example, open-source modules such as Jest and Selenium are good choice to kickstart automation process in your project.

In fact, you can combine it with more sophisticated tools that comes with cloud services and smart reporting. One such tool is [Perfecto](https://www.perfecto.io/free-trial), which comes with free trial version that allows you to:

-   conduct live and automated testing up to 240 minutes, and
-   access a variety of popular real mobile devices via public cloud.

Also, most professional tools come with their own test data and environments which can be easily configured. This helps to simplify the entire testing process. Have a look at the following Github repository which conducts web testing on both:

-   [desktop](https://github.com/PerfectoMobileSA/Jest-perfecto-sample/blob/master/test/webdesktop.spec.js)
-   [mobile](https://github.com/PerfectoMobileSA/Jest-perfecto-sample/blob/master/test/mobileios.spec.js).

You can easily automate your tests inside Perfecto to generate smart reports as illustrated by the image below.

![perfecto page](/img/software-development/devops/testing/perfecto.png)

Image taken from [Perfecto's](https://developers.perfectomobile.com/display/PD/Jest) official documentation


## References

TO-DO
- [Complete Functional Testing Guide With Its Types And Example](https://www.softwaretestinghelp.com/guide-to-functional-testing/#EntryExit_criteria)
- [How to Create Test Cases for Automated tests?](https://www.browserstack.com/guide/test-cases-for-automated-tests)

- [What is Automated Functional Testing: Types, Benefits & Tools](https://www.browserstack.com/guide/what-is-automated-functional-testing)
- [How to run UI Automation Testing using Puppeteer](https://www.browserstack.com/guide/ui-automation-testing-using-puppeteer)
- [The different types of software testing](https://www.atlassian.com/continuous-delivery/software-testing/types-of-software-testing)