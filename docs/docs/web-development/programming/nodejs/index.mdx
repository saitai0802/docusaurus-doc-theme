---
title: "Node.js"
metaTitle: "Git undo changes and remote controls"
metaDescription: "We will discuss topics related to git revert, reset, rebase, stash, fetch, pull, push and merge."
---


## Difference between Node.JS and Javascript
<table>
   <thead>
      <tr>
         <th>S.No</th>
         <th>Javascript</th>
         <th>NodeJS</th>
      </tr>
   </thead>
   <tbody>
      <tr>
         <td>1.</td>
         <td>Javascript is a programming language that is used for writing scripts on the website.</td>
         <td>NodeJS is a Javascript runtime environment.</td>
      </tr>
      <tr>
         <td>2.</td>
         <td>Javascript can only be run in the browsers.</td>
         <td>We can run Javascript outside the browser with the help of NodeJS.</td>
      </tr>
      <tr>
         <td>3.</td>
         <td>It is basically used on the client-side.</td>
         <td>It is mostly used on the server-side.</td>
      </tr>
      <tr>
         <td>4.</td>
         <td>Javascript is capable enough to add HTML and play with the DOM.</td>
         <td>Nodejs does not have capability to add HTML tags.</td>
      </tr>
      <tr>
         <td>5.</td>
         <td>Javascript can run in any browser engine as like JS core in safari and Spidermonkey in Firefox.</td>
         <td>V8 is the Javascript engine inside of node.js that parses and runs Javascript.&nbsp;</td>
      </tr>
      <tr>
         <td>6.</td>
         <td>Javascript is used in frontend development.</td>
         <td>Nodejs is used in server-side development.</td>
      </tr>
      <tr>
         <td>7.</td>
         <td>Some of the javascript frameworks are RamdaJS, TypedJS, etc.</td>
         <td>Some of the Nodejs modules are Lodash, express etc. These modules are to be imported from npm.</td>
      </tr>
      <tr>
         <td>8.</td>
         <td>It is the upgraded version of ECMA script that uses Chrome’s V8 engine written in C++.</td>
         <td>Nodejs is written in C, C++ and Javascript.</td>
      </tr>
   </tbody>
</table>

## process.env.NODE_ENV
Operating system environment variables are widely used as a method of configuring applications, especially as a way to activate behavior based on different deployment environments (such as development vs testing vs production). Node.js exposes the current process’s environment variables to the script as an object called process.env. From there, the Express web server framework popularized using an environment variable called *NODE_ENV* as a flag to indicate whether the server should be running in “development” mode vs “production” mode. At runtime, the script looks up that value by checking *process.env.NODE_ENV*.

Because it was used within the Node ecosystem, browser-focused libraries also started using it to determine what environment they were running in, and using it to control optimizations and debug mode behavior. 

Ultimately, it all comes down to a few key points:

1. *NODE_ENV* is a system environment variable that Node exposes into running scripts.
2. It’s used by convention to determine dev-vs-prod behavior, by both server tools, build scripts, and client-side libraries.
3. It’s commonly used inside of build scripts (such as Webpack config generation) as both an input value and an output value, but the tie between the two is still just convention.
4. Build tools generally do a transform step on the client-side code, replace any references to *process.env.NODE_ENV* with the desired value, and the resulting code will contain dead code blocks as debug-only code is now inside of an if(false)-type condition, ensuring that code doesn’t execute at runtime.
5. Minifier tools such as UglifyJS will strip out the dead code blocks, leaving the production bundle smaller.

## References
[Building Better Bundles: Why process.env.NODE_ENV Matters for Optimized Builds](https://hub.packtpub.com/building-better-bundles-why-processenvnodeenv-matters-optimized-builds/)
